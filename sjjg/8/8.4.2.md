# 选择排序-堆排序 ⭐️⭐️⭐️
选择排序：每一趟在待排序元素中选取关键字*最大/最小*的元素加入有序子序列

若n个关键字序列工t1..n〕满足下面某一条性质，则称为堆(Heap)
①若满足：L(i)≥L(21）且L()≥L(2+1) (1≤i≤n/2)--大根堆（大顶堆）
②若满足：L(i)≤L(2i)且L(i)≤L(2i+1) (1≤i≤n/2) --- 小根堆（小顶堆）
小根堆 09 45 17 65 53 32 87 78

- 参考 二叉树的顺序存储

* 完全二叉树*中共有n个结点，则
* 判断i是否有左孩子？—-2i ≤n?
* 判断i是否有右孩子？—-2i+1≤n?
* 判断i是否是叶子/分支结点？一一i>n/2向下取整？

堆的物理存储 = 完全二叉树（逻辑0的物理存储

大根堆：完全二叉树中，根≥左、右
*对比BST*（Binary Search Tree）左≤根≤右

小根堆：完全二叉树中，根≤左、右

## 算法概念
① 将*初始序列*建立*大根堆* 大根堆：根≥左、右

② 建立+调整 大根堆，思路：把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整。
*非终端结点：i≤n/2向下取整*
e.g. 总结点数为8，那么检查8/2=4的结点
检查当前结点是否满足根≥左、右
若不满足，将当前结点与更大的一个孩子互换

i的左孩子-—2i
i的右孩子-—2i+1
i的父节点-—i/2（向下取整）

- 更小的元素“下坠”，可能导致下-层的子树不待合大根堆的要求
- 若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”的过程）

③ 基于大根堆进行排序

第一趟：
堆排序：每一趟将堆顶元素加入有序子序列
(与*待排序序列*中的最后一个元素交换）
然后堆底最后一个就不用再考虑进这个长度了，重新做一次堆排序即可。
HeadAdjust，其中len-=1  

第二趟：
将堆顶元素加入有序子序列
(与*待排序序列*中的最后一个元素交换(整个的长度导数第二个)）

第 n-1 趟的处理后，就完成了递增的序列。

*如果是小根堆，那么就是递减！*

堆排序：每一趟将堆顶元素加入有序子序列
(与待排序序列中的最后一个元素交换）
并将待排序元素序列再次调整为大根堆
（小元素不断“下坠”）

二算法内容
### 建堆
BuildMaxHeap,初始化大根堆
HeapAdjust，将以 k 为根的子树调整为大根堆
### 排序
HeapSort，堆排序

## 算法效率分析
结论：一个结点，每“下坠”一层，最多只需对比关键字2次
若树高为h，某结点在第i层，则将这个结点向下调整最多只需要“下坠”h-i层，关键字对比次数不超过
2(h-i)
n个结点的完全二叉树树高 h= 【经典的】

第i层最多有2^i-1 个结点，而只有第*1～(h-1)*层的结点才有可能需要“下坠”调整

将整棵树调整为大根堆，关键字对比次数不超过

j=1到h-1的累加，2^(h-j)j

差比数列求和（错位相减法）

建堆的过程，关键字对比次数不超过4n，建堆时间复杂度=O(n）

根节点最多“下坠”h-1层，每下坠一层
而每“下坠”一层，最多只需对比关键字2次，因此每一趙排序复杂度不超过 O(h) = O(log2n)

总n-1趟，总的时间复杂度=O(nlog2n)

堆排序的时间复杂度= O(n) + O(nlog2n) = O(nlog2n)

## 空间复杂度为 O(1)

## 稳定性

e.g. 012（-）2

不稳定！
注意：
建堆时若左右孩子一样大，则优先和左孩子交换



