插入排序

算法思想：每次将一个待排序的记录按其关键字大小插入到前面己排好序的子序列中，直到全部记录插入完成。

【从第二位开始】

手算时相同的字下面带下下划线，然后前面已经排好序的相同关键字不算入排序。


``` c
// 不带哨兵
void InsertSort(int A[], int n) {
    int i, j, temp;
    for (i = 1;i<n;i++) {
        if (A[i] < A[i-1]) {
            temp = A[i];
        }
        for (j = i - 1; j >=0 && A[j] > temp; j--)
            A[j+1] = A[j];
        A[j+1] = temp;
    }
}
```

``` c
// 带哨兵-不用每轮循环判断j是否大于等于零
void InsertSort(int A[], int n) {
    int i, j;
    for (i = 2;i<n;i++) {
        if (A[i] < A[i-1]) {
            A[0] = A[i]; // 放置哨兵
            for (j = i - 1; A[0] < A[j]; j--)
                A[j+1] = A[j];
            A[j+1] = A[0];
        }
    }
}
```
## 空间复杂度
空间复杂度：O(1）
## 时间复杂度
时间复杂度：主要来自对比关键字、移动元素
若有n个元素，则需要 n-1 趟处理

    最好情况：
    原本是顺序
    共n-1趟处理，每一趟只需要对比关键字1次，
    不用移动元素
    n-1次
    最好时间复杂度 O(n)

    最坏情况，原本为逆序
    第1趟：对比关键字2次，移动元素3次
    第2趟：对比关键字3次，移动元素4次
    第i趟：对比关键字 +1次，移动元素 i+2次
    第n-1趟：对比关键字n次，移动元素 n+1次
    最坏时间复杂度-O(n^2)

    平均情况：加和除以2
## 算法稳定性
算法稳定性：稳定

## 优化——折半插入排序
只能顺序表
20 30 40 50 60 70 80 55 60 90 10

当 lowshigh 时折半查找停止，应将 [ low,i-1 ]内的元素全部右移，并将 A【0】 复制到 low 所指位置
当 A【mid】==A【0】时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置

比起“直接插入排序”，比较关键字的次减少了
但是移动元素的次数没变，
整体来看时间复杂度依然是O(n^2)

# 对链表进行插入排序，移动次数变少，但是依旧是O(n^2)的数量级
