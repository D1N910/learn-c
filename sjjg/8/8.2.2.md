# 希尔排序（Shell sort）

算法思想：优化直接插入排序，希尔排序：先追求表中元素部分
有序，再逐渐逼近全局有序。

希尔排序：先将待排序表分割成若干形如 L[ i,i+d,i+2d,...,i+ka ]的“特殊”子表
把相聚距离为kd的看成是相邻的子表，对各个子表分别进行【直接插入排序】。缩小【增量d】，重复上述过程，直到d=1为止。
空 49 38 65 97 76 13 27 49
空(0) 49(1) 38(2) 65(3) 97(4) 76(5) 13(6) 27(7) 49(8)
第一趟：d1=n/2+4，那么49和76是同一个子表，因为49的下标为1,1+4=5是76的下标。同理，38、76和65、27也是同一个子表。
第二趟：d2=d1/2=2
第三趟：d3=d3/3=1,这一次是相当于对于所有的元素进行直接插入排序

希尔本人建议：每次将增量缩小一半.

## 空间复杂度
空间复杂度：O(1）
## 时间复杂度
时间复杂度：和增量序列 di，d2,d3.的选择有关，目前无法用数学手段证明确切的时间复杂度
最坏时间复杂度为 O(n^2)，当n在某个范围内时，可达O(n^1.3)
如果增量变成1，那么就退化了
## 稳定性
不稳定！（因为划分成了不同的表！

原始序列：
65、49、49（-）
第一趟：d=2
49（-）、49、65
第二趟：d=1
49（-）、49、65

## 适用性：仅适用于顺序表，不适用于链表（因为增量d要用顺序表）

## 高频题型：给出增量序列，分析每一趟排序后的状态