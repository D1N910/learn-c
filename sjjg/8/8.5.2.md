# 基数排序(Radix Sort) - 不是基于比较的排序算法

要求：得到按关键字“递减”的有序序列。

520-》211-》438-》-》888-》007-》111-》985-》666-》996-》233-》168

Q9 Q8 Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0【队列存储，按照进制】

第一趟：
以个位”进行“分配”
e.g. Q8->438（队头）->888->168->队尾
分配“结束”
“收集”
从最左（个位最大）到右，从队头到队尾。第一趟收集”结束：得到按`”个位”递减排序`的序列
438 - 888 - 116 - 007 - 666 --996- 985- 233- 211-111-520

第二趟：以“十位”进行“分配”
注意到这时 “个位”越大的越先入队
第二趟“收集”：
从最左（个位最大）到右，从队头到队尾。第二趟收集”结束：得到按`”十位”递减排序`的序列

第三趟：以“百位”进行“分配”
注意到这时 “十位”越大的越先入队
第三趟按“百位”分配、收集：得到一个按”百位”递减排列的序列，若“百位”相同则按”“十位”递减
排列，若"十位”还相同则按”个位”递减排列

假设长度为n的线性表中每个结点a的关键字由d元元组。
最高位关键字（最主位关键字）
最低位关键字（最次位关键字）
r成为基数

## 基数排序得到递减序列的过程如下

初始化： 设置r个空队列
按照各个 关键字位 权重递增的次序
按照各个 关键字位 权重递增的次序（个、十、百)，对d个关键字位分别做“分配”和“收集”
`分配`：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入Q队尾

收集：把 Qr1， Qr-2,. Qo各个队列中的队并链接

如果想要得到递减的，那么久先收集最高位的

## 算法效率分析

基数排序通常基于于链式存储实现
``` c
LinkQueue Q[10];
typedef struct LinkNode {
    ELemType data;
    struct LinkNode *next;
}LinkNode, *LinkList;
typedef struct{
    //链式队列
    LinkNode *front,*rear; //队列的队头和队尾指针
}LinkQueue;
```

## 需要 r 个辅助队列，空间复杂度= O(r)，r=每个位可能得取值范围

## 一趟分配O(n)，一趟收集O(r)，总共d（位数）趟分配、收集，总的`时间复杂度=O(d(n+r)`

p->next = Q[ 5 ].front; // front指向第一个结点，所以收集很方便
Q[ 5 ].front=NULL;
Q[ 5 ].rear=NULL;

## 稳定性
稳定的
基数排序是`稳定的`——基你太稳，小黑子

某学校有 10000 学生，将学生信息按年龄递减排序
生日可拆分为三组关键字：年(1991~2005）、月（1~12）、日（1~31)

权重：年>月>日

注意，这里递减年龄，那么年、月、日越大，年龄越小。

第一趟分配、收集（按“日”递增）：
第二趟分配、收集（按“月”递增）：
第三趟分配、收集（按“年”递增）：

基数排序，时间复杂度=o(d(n+r))
d=3,n=1000,r=31（按照最大的！）

基数排序，时间复杂度 = O(d(n+r))~ O(30000)

若采用O(n2)的排序，~O(108L
若采用O(nlog2n)的排序，~O(140000)

基数排序擅长解决的问题：
①数据元素的关键字可以方便地拆分为d组(关键字的分组，位数，个十百)，且d较小 * 反例：给5个人的身份证号排序
②每组关键字的取值范围不大，即r较小（具体到有多少天，多少年） * 反例：给中文人名排序 每个字可能有上万种取值
③数据元素个数n较大（适合大数据） *擅长：给十亿人的身份证号排序