# 快速排序
基于“交换”的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置

* 性能最好

pivot
英/ˈpɪvət/ 美/ˈpɪvət/
n.
支点，枢轴；最重要的人（或事物），核心；转动，旋转；策应位置；<美>中锋

v.
（使）在枢轴上旋转；（以脚为支点）转身；（为机械装置）提供枢轴

算法思想：在待排序表L1..]中任取一个元素pivot作作为枢轴（或基油，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1..k-1]和L[k+1..n]，使得L1...k-1中的所有元素小于pivot， L[k+1...nl中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至
每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。

## 实现思路
更小的元素都交换到左边
更大的元素都交换到右边

用第一个元素把待排序序列“划分”为两个部分。左边更小，右边更大。【该元素的最终位置已确定】。

用一个low指针和一个high指针不断地指向下一个元素，low指pivot初始位置，先让high指，如果指到的比pivot的更小，那么替换到low的位置，然后low开始查找，如此反复 直到 low = high，那么位置就是low所处的位置。需要注意的是，这样查找后，最终位置已经确定下来了。

如果左右只有一个或者0个元素，那么久不用再处理了

## 算法效率分析
每一层的QuickSort/只需要处理剩余的
待排序元素，时间复杂度不超过O(n)

n个结点的二叉树
最小高度= 【经典算数】log2n+1
最大高度= n
### 时间复杂度=0(n*递归层数）
和递归层数息息相关

最好时间复杂度=O(nlogen)
最坏时间复杂度=O(n^2)

平均时间复杂度=O(nlog2n)

### 空间复杂度=0(递归层数） - 占用栈
把n个元素组织成二叉树，二叉树的层数就是递归调用的层数
最好空间复杂度=O(log2n)
最坏空间复杂度=O(n)

### 要点
若每一次选中的“枢轴”将待排序序列划分为*均匀的两个部分*，则递归深度最小，算法*效率最高*

越是顺序的表越不利！
若初始序列*有序*或*逆序*，则*快速排序的性能最差*（因为每次选择的都是*最靠边*的元素）

快速排序算法优化思路：尽量选择可以把
数据中分的枢轴元素。（中分！只因你太美！）
eg：①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选一个元素作为枢轴元素

## 稳定性
不稳定！
e.g.

2(-)21

开始2(-)作为枢纽，high指向为1，那么1放到low的位置
12__

由于low指向1、指向2都不大于2（-），那么最终指向最后一个位置。
最终排序
122（-）
不稳定！

注：408原题中说，对所有*尚未确定最终位置*的所有元素进行*一遍处理*称为“一趟”排序，因此一次“划分”≠一趟排序。

一次划分可以确定一个元素的最终位置，而一趟排序也许可以确定多个元素的最终位置。

快速排序的第二次换分才算是一趟排序