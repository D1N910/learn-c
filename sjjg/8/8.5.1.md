# 什么是 Merge（归并/合并）？

## 归并：把两个或多个已经有序的序列合并成一个

## 思路
1、设定一个更大的数组
对比i、j所指元素，选择更小的一个放入k所指位置

只剩一个子表末合井时，可以将该表中剩余元素全部加到总表

## “2路”归并

归并：把两个 或`多个`已经有序的序列合并成一个

“4路”归井一一每选出一个小元素需对比关键字3次

对于每条路的关键词进行逐次对比，1对比2得到更小的

结论： `m路归并，每选出一个元素需要对比关键字m-1次`

## 归并排序（手算模拟）

初始序列：49 38 65 97 76 13 27
每个当作单独的有序序列，作二路排序
一趟归并后：38-49 65-97 13-76 27
二趟归并后：38-49-65-97  13-27-76
三趟归并后：13-27-38-49-65-76-97  

在`内部排序`中一般采用2路归并。内部排序-》主存中的排序，没有磁盘操作。

核心操作：把数组内的两个相邻的有序序列归并为一个

### 算法

A[]各自有序， B[]存放数据。
A[]中low、mid、high区分出两个相邻字符串。low是A串头部元素，mid是A串尾部元素。high是B串尾部元素。

拷贝：
B[]中先拷贝对应内容，在B中i指针指向low，j指针指向mid+1。然后同二路归并，把值归并回A串。
如果i、j对应的值相同，有限拷贝i指针的值，保证稳定性

没有归井完的部分复制到尾部

## 算法效率分析
2路归并的“归并树”一一形态上就是一棵倒立的二叉树

二叉树的第h层最多有2^(h-1)个结点
若树高为h，则应满足n≤2^(h-1)

即h-1= log2n向下取整

结论：n个元素进行2路归并排序，归并趟数 = h-1（树高-1）
### 每趟归并时间复杂度为 O(n)，则算法时间复杂度为 O(nlog2n)

每次对比是<=n-1次的，用指针i、j进行对比，进行两两对比，每次对比时间复杂度为 O(n)

### 空间复杂度=0(n)，来自于辅助数组B，递归栈的空间复杂度为O(log2n)，加法被抵消了

## 稳定性
稳定的