# 5.4.1md
## 知识总览
- 树的逻辑结构回顾
- 双亲表示法
- 孩子表示法
- 孩子兄弟表示法
- 重要考点：树、森林与二叉树的转换

## 树的逻辑结构
- 是 n(n>=0)个结点的有限集合，n=0时，称为`空树`，是一种特殊情况。
- `非空树`
- - 1 有且仅有一个特定的称为根的结点。
- - 2 当 n>1 时，其余结点可分为 m (m>0) 个互不相交的有限集合 T1，T2,...,Tm，其中每个集合本身又是一棵树，并称为根节点的子树

## 双亲表示法
顺序存储
- data存储当前数据
- parent存储双亲（父）位置
``` c
typedef struct {
    ElemType data;
    int parent;
}PTNode;

typedef struct{
    PTNode node[MAX_TREE_SIZE]; // 双亲表示
    int n; // 节点数
}PTree;

```

### 增加
增加一个新节点，只需要把 partent 指向父节点所在的位置就行；物理上的位置是可以不用按照次序

### 删除叶子结点
- 方案一 去掉这个元素的值，把这个元素的 parent 设置为 -1；
- 方案二 把尾部的数据移上去，填充空白，这样保证前面所有的节点都是有效的。（这种方案更好）

### 删除结点
- 要删除所有的孩子节点
- 依次从头遍历，如patent节点指向当前要删除的节点，那么就删除之。

## 二叉树的顺序存储
编号按照层一一对应存储。

## 孩子表示法（顺序存储+链式存储）
顺序存储各个结点，每个结点中保存孩子链表头指针

```
struct CTNode {
    int child; // 孩子结点在数组中的位置
    struct CTNode *next; // 下一个孩子
}PTNode;

typedef struct {
    ElemType data;
    struct CTNode *firstChild; // 第一个孩子
}CBox;

typedef struct 
{
    CBox nodes[MAX_TREE_SIZE];
    int n; // 结点的个数和根的位置
};
```

- 找孩子很方便，找双亲不方便

## * 孩子兄弟表示法（链式存储），可参考二叉树的结点 最常考

struct CSNode {
    ElemType data; // 数据域
    struct CSNode *firstchild,*nextsibling; // 第一个孩子和右兄弟指针
}CSNode, * CSTree;

看的时候按照二叉树的来看关系，那么这样就把树和二叉树相互转换了。

用孩子兄弟表示法存储的树在物理上呈现出“二叉树”的例子

- 1、第一个结点是根节点；
- 2、二叉树形态时，左孩子结点是第一个孩子结点，右孩子结点是第一个右兄弟结点。

## 森林和二叉树的转换

森林：是m棵互不相交的树的集合（m>=0）

- 1、先把森林里的各个树二叉树化；
- 2、树的根节点互不相交，可以认为是兄弟节点，用右节点连在一起。

所以二叉树根节点只有一个孩子节点，那么是从树转换的；如果二叉树根节点有两个孩子节点，那么就是从森林转换的。