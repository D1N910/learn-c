## 代码实现前中后序遍历 （完成）

## 二叉树的层次遍历
（1）初始化一个辅助队列；
（2）根节点入队；
（3）若队列非空，则队头节点出列，访问改节点，并将其左、右孩子插入队尾（如果有的话）；
（4）重复（3）直到队列为空

## 由遍历序列构造二叉树

中/前/后序遍历序列，只给出一种-—不能倒推出二叉树

给出这三种才能推出：前+中、后+中、层+中

key：先找到树的根节点，并根据中序序列划分左右子树；再找到左右子树根节点；


## 线索二叉树的概念

- 对于二叉树不能够从制定结点开始遍历
- 如何找到指定结点的前驱 —— p代表要被查找的结点，从根节点出发，重新进行一次中序遍历，用一个q记录当前访问的结点，指针pre记录上一个被访问的结点，当q == p 时，pre为前驱。

### 线索，如果左孩子是NULL，且有前驱，那么指向前驱，如果没有前驱，就指向NULL；如果y右孩子是NULL，且有后驱，那么右孩子就指向后驱。通过ltag、rtag来代表对应的孩子指向的是后继或者前继还是孩子节点，1代表室线索，0代表孩子

前驱线索、后驱线索：分别指向前驱和后驱

### 找到中序前驱
和土办法一样，一个个遍历着到。
``` c
// 辅助全局变量，用于查找结点p的前驱
BiTNode * p; // p指向目标结点
BiTNode * pre=NULL; // 指向当前访问结点的前驱
BiTNode * final=NULL; // 用于记录最终结果
...
// 访问结点q
void visit(BiTree q) {
    if (q == p) // 当前访问的结点刚好是结点P
        final = pre; // 找到p的前驱
    else
        pre = q; // pre 只指向当前的结点
    printf("%d ", q->data);
}
```

<!-- 线索化 -->
``` c
// 中序线索化二叉树
void CreateInThread(ThreadTree T) {
    pre = NULL;
    InThread(T);
    if (pre!= NULL&&pre->rchild==NULL) {
        pre->rtag = 1;
    }
}

// 中序遍历，一边遍历一边线索化
void InThread(ThreadTree T) {
    if (T != NULL) {
        InThread(T->lchild);
        visit(T);
        InThread(T->rchild);
    }
}

// 访问结点q
void visit(ThreadTree q) {
    if (q->lchild == NULL) { // 左子树为空，那么指向前驱
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre!=NULL&&pre->rchild==NULL) {
        pre->rchild = q; // 建立前驱结点的后继搜索
        pre->rtag = 1;
    }
    pre = q; // pre 只指向当前的结点
    printf("%d ", q->data);
}
```

### 易错点

* 最后还要检查 pre 的 rchild 是否为 NULL，如果是的话，则令 rtag = 1。需要对最后一个结点进行处理。

* 先序线索化中，注意处理爱滴魔力转圈圈问题，当ltag == 0 时，才能对左子树先序线索化。（中序和后续都不会出现这个问题）

## 线索二叉树给定一个接地那找前驱和后继

### 中序线索二叉树找中序[后继]

- 1 如果 p->rtag==1,则 next = p->rchild;
- 2 如果 p->rtag==0,则一定有右孩子，非空。
- - 那么如果右孩子是叶子节点，那么就是右孩子为后继，next = p->rchild;
- - 如果右孩子又左节点，那么就是要继续展开找。。。next = p的左子树最左下角节点;

``` C
// 找到以p为根的子树中，第一个被中序遍历的节点
ThreadNode *FirstNode(ThreadNode *p) {
    // 循环找到最左下节点，不一定是叶子节点)
    while (p->ltag == 0) p->lchild;
    return p;
}

// 在中序线索二叉树中找到结点p的后继结点
ThreadNode *NextNode(ThreadNode *p) {
    if (p->rtag == 0) return FirstNode(p);
    else return p->rchild; // rtag == 1 直接返回右结点
}
```
5.3_6代码 todo
## 先序最麻烦，分四种情况，用父结点。
1、能找到p的父结点，且p是左孩子；—— P的父结点就是前驱；
2、能找到p的父结点，且p是右孩子，父结点没左孩子；—— P的父结点就是前驱；
3、能找到p的父结点，且p是右孩子，父结点有左孩子；—— a的前驱为左兄弟最后一个被先序遍历的节点；
4、如果p是根节点，那么p没有前驱。

todo

要实现代码。