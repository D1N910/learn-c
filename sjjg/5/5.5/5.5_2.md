# 并查集

## 知识总览
- 如何表示”集合“关系？
- ”并查集“的代码实现
- ”并查集“的优化

三要素：逻辑结构、物理结构（存储结构）、基本操作（算法）

## 逻辑结构
逻辑结构 —— 数据之间的逻辑关系是什么？

集合关系、树形结构、图结构、线性结构

* 并查集 - 集合

子集：将各个元素划分为若干个互不相交的子集，比如吃葡萄的、吃苹果的。

元素关系：要么从属于一个集合，要么从属于不同的集合。

- 参考树和森林，森林就是互不相交的树的集合
- 同一个子集中的各个元素，组织成一棵树
- 不同的子集就放到不同的树里

常见场景：

”查“到一个元素到底属于哪一个集合
- 1 给定一个元素，判断属于哪个集合；方法：从指定元素出发，一路向北，找到根节点
- 2 给定两个元素，判断是否从属一个集合；方法：从指定元素出发，一路向北，找到根节点，对比根节点是否相同就知道是否属于一个根节点。


”并“ 如何把两个集合“并”为一个集合？
- 1 只需要把一棵树称为另一颗树的根节点

“并查集” - 就是上面两个操作。

代码实现：

双亲表示法(用来表示并查集)、孩子表示法、孩子兄弟表示法（二叉树）

## 双亲表示法

根节点的parent对应为 -1

用双亲表示法

- 并操作时间复杂度：o(1)

- 查操作：时间复杂度，较好的情况下只用 1 次，最坏的情况下要查 n 次（n为树的高度）
``` c
// 并 合并指定的集合 普通
void Union(int S[], int Root1, int Root2) {
    // 相同根不连接
    if (Root1 == Root2) return;
    S[Root2] = Root1;
}
```

- - 优化思路，每次 Union操作构建树的时候，尽可能让树不长高高
- - 1、用根节点的绝对值表示树的结点总数
- - 2、Union 操作，让小树合并到大树
- - 优化后，树的高度不超过 log(2)n + 1 这个数量级（数学归纳法来得到）
- - 那么查的操作最坏的时间复杂度为 log(2)n + 1 
``` c
// 并 合并指定的集合 优化
void Union(int S[], int Root1, int Root2) {
    // 相同根不连接
    if (Root1 == Root2) return;
    // 将根连接到另一个绝对值更大的根下面
    if (-S[Root2] < -S[Root1]) {
        S[Root1] += S[Root2];
        S[Root2] = Root1;
    }
    else {
        S[Root2] += S[Root1];
        S[Root1] = Root2;
    }
}
```