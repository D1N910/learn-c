# 字符串的模式匹配

平常搜索的时候，文字匹配上内容。

主串：被搜索的字符串，e.g. '的；蓝思科技分类考试了福克斯低硫费时空来电荆防颗粒三对角发了空数据付老师讲道理副驾驶两地分'

子串： 主串的一部分，一定存在

模式串: '试了福克斯低硫费时空来'，不一定存在

字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。

## 考点
- 朴素模式匹配算法
- KMP 算法

## 朴素模式匹配算法

### 思想

暴力解决问题：从头到尾一个个匹配

主串长度为n，模式串长度为m

朴素模式匹配算法：将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。

4.1的Index算法

子串数量max: n-m+1，最多匹配 n-m+1 次

最差的情况下：复杂度: &O(mn)& 很多时候 n>>m

不适用字符串操作，直接通过数组下标完成操作。

用两个指针实现，主串指针指向下一个子串的第一个位置，模式串指针j回到模式串的第一个位置。

循环体内匹配失败重置：i = i - j + 2; j = 1;

循环体内匹配成功： j>T.length

返回当前子串第一个字符的位置 ———— i - T.length

## KMP 算法（KMP代表三个人）

已匹配过的元素的内容是知道的，可以跳过；

然后停留在已经适配了的地方。令主串指针i不变，模式串指针 j 变化。

和主串无关，和模式串有通用关系。

第一个适配不到很特殊，要修改为 0，然后i、j 统一++。

用next[]存储j的匹配不到值时的，起匹配的k值。

根据模式串 T，求出 next 数组。利用next数组进行匹配（主串不匹配）

区别：一个回溯，一个不回溯。

KMP算法：最坏时间复杂度 O(m + n),其中求 next 数组时间复杂度 O(m),模式匹配过程最坏时间复杂度O(n).