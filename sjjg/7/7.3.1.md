二叉排序树（BTS，Binart Search Tree）
左子树结点值 < 根节点 <右子树

左中右，中序遍历。

查找很方便
可以 T 不为NULL
1、如果比节点大，那么 T = T->rchild
2、如果比节点小，那么 T = T->lchild
3、如果和节点相同，那么成功，返回节点 T

二叉排序树的构造不同序列可能相同，可能不相同

最终返回非 NULL 匹配成功

二叉排序树的删除
1、如果结点z是叶子结点，直接删除即可
2、如果结点z只有一颗左子树或右子树，则让z的子树成为z父节点的子树，替代z的位置
3、保证【左子树结点值 < 根节点 <右子树】
    A、若结点z有左、右两棵子树，则令z的直接后继替代z
（*进行中序遍历，可以得到一个递增的有序序列。其实就是右子树的最左下角，对右子树进行中序遍历得到的第一个值）
然后从二叉排序树中删去这个直接后继，这样就转换成了第一或第二种情况。（必然没有左子树，如果有右子树则用右子树替代，如果没有右子树，那么说明是叶子节点，直接删掉自己）
    B、A方案 直接后继 -> 直接前驱，左子树的中序遍历最后一个，其中直接前驱必然没有右子树，如果有左子树则用左子树替代，如果没有左子树，那么说明是叶子节点，直接删掉自己

查找效率分析
查找长度一一在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度
代码角度，每次查找就是一次递归，长度和操作时间复杂度一样，

查找成功
查找成功平均查找长度 ASL ( Average Search Length)
ASL= (1*1+2*2+3*4+4*1)/8=2.625

若树高h，找到最下层的一个结点需要对比h次。查找次数和高度很相关。

最好情况:树最小高度为 log(2)n 向下取整 + 1.平均查找长度=O(log(2)n)
最坏情况：每个结点只有一个分支，树高h=结点数n。平均查找长度=0(n）

查找失败 * 易错点，把失败节点也当成了一次对比，计算了进去
* 二叉树失败节点 = 空节点总数 = n+1