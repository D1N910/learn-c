# 散列表 (Hash Table) = 哈希表
哈希查找 = 散列查找，哈希函数 = 散列函数
## 定义
散列表 (Hash Table)，又称哈希表。是一种数据结构，特点是：数据元素的关键字与其
存储地址直接相关

如何建立“关键字”与“存储地址”的联系？
通过“散列函数（哈希函数）”：Addr=H(key)

例：有一堆数据元素，关键字分别为 {19,14, 23, 1, 68, 20,84,27, 55, 11, 10,79)，散列函数
H(key)=key%13

同义词: 若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”
冲突: 通过散列函数确定的位置已经存放了其他元素，则称这种情况为

## 处理冲突的方法-拉链法（链地址法）
数组保存链表指针
用拉链（又称链接法，链地址法）处理“冲突”：把所有“同义词”存储在一个链表中

## 散列查找
次数是 H(key) = key%m 找到位置后，然后在链表里比对的次数

查找长度——在查找运算中，需要【对比关键字的次数】称为查找长度 ‼️
那么如果数组中本身存的链表地址为NULL，说明直接查找失败，那么这次的查找长度为0
* 大多数学校的计算方法，408方法。当然某些学校会把这个空指针的比较也算是比较，所以要看往年真题和答案。

### 成功 ASL
每次查找的概率相同，查找关键字的长度之和（链表第一行只用一次，链表第二次两个...）/【关键字数量】

“冲突”越多，查找效率越低

没有“冲突”也就是同义词没有，那么查找长度为0(1)最好

### 查找失败
设n为存储关键字的数组的长度，那么每个数字匹配到每个位置的概率一样。匹配到没有数据的位置当然查找次数为0；匹配到有值的位置的查找次数就是对应位置存的值的数量。
所以
ASL失败 = [0 + 0 + 0（没有存数的）+ 4（假设某个地方存了值）]/n(重点)

## 常见的散列函数
### 除留余数法 — H(key) = key % p
散列表表长为m，取一个不大于m但最接近或等于m的【质数】p
质数又称素数。指除了1和此整数自身外，不能被其他自然数整除的数。
（相反的概念是合树，比如8）

设计目标一一让不同关键字的冲突尽可能地少

* 并不是说按质数来一定更优秀，比如是顺序紧挨着的就不一定；但是在大多数情况下，乱序，可以让分布得更加均匀！
Why?一一用质数取模， 分布更均匀，冲突更少。参见《数论》* 以后要学数论

### 直接定址法 H(key) = key 或 H(key) = a*key +b
其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合[ 关键字的分布基本连续 ]的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

例：存储同一个班级的学生信息，班内学生学号为（1120112176~1120112205)
H(key) = key - 1120112176

### 数字分析法—选取数码分布较为均匀的若干位作为散列地址
设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些1
上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常
现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合
若更换了关键字，则需要重新构造新的散列函数。
例：以“手机号码”作为关键字设计散列函数
138XXXX2875
138XXXX1682
138XXXX9125
199XXXX1684
199XXXX1236

e.g. 取后四位作为散列地址

### 平方取中法一一取关键字的平方值的中间几位作为散列地址，
具体取多少位要视实际情况而定。【这种方法得到的散列地址与关键字的每位都有关系】，因此使得
散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

1310^2=1,716,100
1110^2=1,232,100
1300^2=1,690,000
1210^2= 1,464,100
1200^2=1,440,000
[ 中间的三位和数码是相关的，分布均匀，和任何一个数码位相关 ]

例：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数
身份证号码规则：
前1、2位数字表示：所在省份的代码；
第3、4位数字表示：所在城市的代码；
第5、6位数字表示：所在区县的代码；
第7-14位数字表示：出生年、月、日；
第15、16位数字表示：所在地的派出所的代码；
第17位数字表示性别：奇数表示男性，偶数表示女性；
第18位数字是校检码。

* 其实很多都是分布不均匀的，那么就可以取中间的号来放

想要绝对避免冲突，可以直接非常长

例：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数

若散列表的长度为1000000000000000000（别数了，有18个04)
则可以直接用身份证号作为散列地址，且不可能有冲突，查找时间复杂度为O(1)
* 不实际

散列查找是典型的“用空间换时间”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。

## 处理冲突的方法一开放定址法
例：有一堆数据元素，关键字分别为 {19,14, 23, 1, 68, 20, 84,27,55,11，10,79)，散列函数
H(key)=key%13

所谓【开放定址法】，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：
H = (H(key) + d) %m
i=0,1,2…k(ksm-1)，【m】表示【散列表表长】；【di】为【增量序列】；i可理解为“第i次发生冲突”


### ①线性探测法
#### 插入数据
d=0,1,2,3,.m-1； 即发生冲突时，每次往后探测相邻的下一个单元是否为空。
注意分母用的是整个表的表长。
* e.g.
* * 第0次 H = (H(key) + 0) %m
* * 第1次 H = H = (H(key) + 1) %m // 发生第1次冲突后重新计算得到的哈希地址
#### 查找数据
1、和同义词也和非同义词比
2、和空位置的对比也算是一次比较，直到比对到真正空缺的才失败（和拉链表相比的话，拉链表如果一开始比对不上，不算是比对次数的原因是因为拉链表存储的是Null，空指针，直接无法比对
### 删除操作
1、如果直接删除了一个地方的元素，把它真的删了，那么查找的时候它是空的，那么就断掉了
注意：采用“开放定址法”时，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入
散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除
考试就喜欢考线性探测法！
存在看起来很满，实际上很空的情况（因为前面的可能都删了）

#### 问题
线性探测法很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率
产生原因——冲突后再探测一定是放在某个连续的位置

### ②平方探测法 - 解决聚集问题
当d= 0、d1= 1、d2= -1、d3= 4、d4= -4、d5= 9、d6= -9时，称为平方探测法，又称【二次探测法】其中 k<=m/2

平方探测法：比起线性探测法更不易产生“聚集（堆积）”问题

#### 问题
非重点小坑：散列表长度m必须是一个可以表示成4j+3的素数，才能探测到所有位置   

### ③伪随机序列法

di是一个实现生成好的伪随机序列，如 d= 0, 5, 24, 11,.

## 处理冲突的方法一再散列法 严蔚敏《数据结构》
再散列法（再哈希法）：除了原始的散列函数 H(key)之外，多准备几个散列函数，
当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：
H= RH(Key) i=1,2,3..k

# 做题遇到的坑
## 装填因子
装填因子：a=n/m 其中n 为关键字个数，m为表长。

加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.

冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.

因此,必须在 "冲突的机会"与"空间利用率"之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的"时-空"矛盾的平衡与折衷.

在散列表中，平均查找长度与装填因子a直接相关，表的查找效率不直接依赖于表中己有表
项个数n或表长m。若散列表中存放的记录全部是某个地世的
则平均查找长度为 O(n)非 O(1)

* 通过装填因子算出的m要向上取整