# 平衡二叉树
# 定义
平衡二叉树的定义
（M. Adelson- Velsly 和 E. M. Landis)
平衡二叉树(Balanced Binary Tree），简称平衡树（AVL树）一一树上任一结点的左子树和右子树的
高度之差不超过1。
结点的平衡因子=左子树高-右子树高。
平衡二叉树结点的平衡因子的值只可能是-1、0或1。

* 需要保存多一个平衡因子 balance

只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树
# 插入操作
在二叉排序树中插入新结点后，如何保持平衡？
查找路径上的所有结点都有可能受到影响

从插入点往回找到第一个不平衡结点，调整以该结点为根的子树(最小的那颗子树)

# 插入新结点后如何调整！不平衡！问题，调整最小不平衡树【A】

--------------------A（平衡因子1，高度H+1）--------------
-----B（平衡因子0，高度H+1）-----------AR（高度H）---------
--BL（高度H）---BR(高度H)-------------------------------

* 讨论时，假定所有的子树高度都是 H 而不是 H+1、H-1。
* 因为如果是H+1，那么新增了一个以后不会不平衡，就不值得讨论了。
* 如果是 AR 为 H-1，那么A的平衡因子为2，那么本来就是不平衡的，但是我们这边讨论的是本来是平衡的；
* 如果是 BR 为 H-1，那么最小不平衡树在BL新加入后就变成了B而不是A了。

目标：1.恢复平衡：2.保持二叉排序树特性

## LL 在A的左孩子的左子树中插入导致不平衡 （右单旋转）
LL平衡旋转（右单旋转）。由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡_需要一次向右的旋转操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为8的右子树的根结点，而B的原右子树则作为A结点的左子树。
-------------------B（平衡因子1，高度H+1）--------------
--BL（高度H+1）-------------------------A(高度H+1)--------------------
--------------------A->BR（高度H）-------------A->AR（高度H）-----
    实现f向右下旋转，p向右上旋转：
    其中f是爹，p为左孩子，gf为f他爹
    ① f->lchild = p->rchild;
    ② p->rchild = f;
    ③ gf->lchild/rchild = p；
    左旋、右旋操作后可以保持二叉排序树的特性
## RR 在A的右孩子的右子树中插入导致不平衡（左单旋转）-类似 LL

## LR 在A的左孩子的右子树中插入导致不平衡（先左后右双旋转）
--------------------A（平衡因子1，高度H+1）--------------
-----B（左孩子）-----------AR---------
--BL------C（左孩子的右子树）（H+1）-------------
------ CL（H） --- CR（H-1） ------
LR平衡旋转（先左后右双旋转）。由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转、先将A结点的左孩子B的右子树的根结点C向在上加转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位買

左旋：C的左孩子变成B；B的右孩子变成原来C的左孩子；
右旋：C的右孩子变成A；A的左孩子变成原来C的右孩子；
代码实现
    实现f向右下旋转，p向左下旋转，q先左旋转然后右旋转：
    其中f是爹，p为左孩子，gf为f他爹，q为p的右孩子
    ① p->rchild = q->lchild;
    ② q->lchild = p;
    ② f->lchild = q->rchild;
    ③ q->rchild = f;
    ④ gf->lchild/rchild = q；
    左旋、右旋操作后可以保持二叉排序树的特性

## RL 在A的右孩子的左子树中插入导致不平衡（先右旋后左双旋转）

只有左孩子才能进行右上旋；只有右孩子才能左上旋；
左右、右左按照名字来转；
总之最后A都没了

插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复。则依次恢复。每次调整的是最小的，每次调整了最小的，祖先都会恢复平衡。
调整后注意
# 查找效率分析
查找效率分析
若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能
超过 O(h)
平衡二叉树一一树上任一结点的左子树和右子树的高度之差不超过1。
假设以N)表示深度为h的平衡树中含有的最少结点数。
则有no=0,n1=1,n2=2，并且有nh = n(h-1)+ n(h-2) +1（根节点）
n3=4、n4=7、n5=12
可以证明含有n个结点的平衡二叉树的最大深度为O(log2n)，平衡二叉树的平均查找长度为O(log2n)


# 平衡二叉树的删除
平衡二叉树的删除操作：
删除结点后，要保持二叉排序树的特性不变（左<中<右）
若删除结点导致不平衡，则需要调整平衡
平衡二叉树的删除操作具体步骤：
①删除结点（方法同“二叉排序树”）
    若删除的结点是叶子，直接删。
    若删除的结点只有一个子树，用子树顶替删除位置。
    若删除的结点有两棵子树，用前驱或后继结点顶替，并转换为对前驱（或后继）删除。
②一路向北(删除节点往上找)找到最小不平衡子树，找不到就完结撒花
③找最小不平衡子树下，“个头”最高的儿子、孙子
④根据孙子的位置，调整平衡（LL/RR/LR/RL)
⑤如果不平衡向上传导，继续② 

平衡二叉树删除操作时间复杂度=O(log,n)