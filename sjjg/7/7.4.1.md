# B树，对付M叉查找树

``` c
//5叉排序树的结点定义
struct Node {
    ELemType keys [4]; //最多4个关键字
    struct Node * child[5];//最多5个孩子
    int num; //结点中有几个关键字
}；
```

关键字夹在孩子之间。查找节点内关键字有序排放，顺序查找；
如果 < keys[i],那么访问 child[i]；
如果越界，那么访问child[i+1]，i是上次对比的关键字的下标。
如果超出范围，那么

每个结点内的也可以查找

若每个结点内关键字太少，导致树变高，要查更多层结点，效率低

## 如何保证查找效率
### 节点内
策略：m叉查找树中，规定除了根结点之外，任何结点至少有m/2向上取整个个分叉，即至少含有m/2向上取整个关键字

### 策略：m叉查找树中，规定对于任何一个结点，其子树高度都相同
不够“平衡”，树会很高，要查很多层结点

## B树 定义
B树，又称【多路平衡查找树】，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：
1）树中每个结点至多有m棵子树，即至多含有m-1个关键字。
2）若根结点不是终端结点，则至少有两棵子树。
3) 除根结点外的所有非叶结点至少有 m/2 向上取整棵子树，即至少含有 m/2 向上取整 -1 个关键字。
5) 所有的【叶结点】都出现在`同一层次`上，并且`不带信息`（可以视为`外部结点`或类似于`折半查找判定树`的`查找失败结点`，实际上这些`结点不存在`，指向这些结点的`指针为空`）

4）所有非叶结点的结构如下：
n Po K1 P K2 P2 …. Kn, Pn
其中，Ki（i=1,2…,n)为结点的关键字，且满足K1＜K2 <...＜ Kn Pi (i = 0, 1.， n）为指向子树根结点
的指针，且指针Pi-1所指子树中所有结点的关键字均小于Ki，P所指子树中所有结点的关键字均大于Ki，
(Im/21- 1≤n≤m - 1)为结点中关键字的个数。

## m阶B树的核心特性 核心要求：
1) 根节点的子树数∈[2,m]，关键字数∈[1,m-1]。
其他结点的子树数∈[m/2向上取整，m]；关键字数∈[`m/2向上取整-1`, m-1]
2）对任一结点，其所有子树高度都相同
3）关键字的值：子树O<关键字1<子树1<关键字2<子树2<…（类比二叉查找树 左<中<右)

注：大部分学校算B树的高度不包括叶子 结点（失败结点）

最小高度——让每个结点尽可能的满，有m-1个关键字，m个分叉，则有n≤(m -1)(1 +m+m?+m°+….+mb-)）=mh-1，因此h≥ log,(n + 1)
B树高度最小值为 h>=log(m)(n+1)

最大高度——让各层的分叉尽可能的少，即根节点只有2个分叉，其他结点只有（m/21个分叉
各层结点至少有：第一层1、第二层2、第三层 2Im/21 .. 第h层2（[m/21)2
第h+1层共有叶子结点（失败结点）2(mm/21)-1个
B树高度最大值为 h<=log(m/2向上取整)[ (n+1)/2 ] + 1

n个关键字的B树必有n+1个叶子结点（e.g. 2个结点把无穷区间分为了3块，一块对应一个节点）

# B树的插入

1、在插入key后，若导致原结点关键字数超过上限，则从中间位置 m/2 向上取整。将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置 m/2 向上取整，的结点插入原结点的父结点。

2、新元素一定是插入到最底层的“终端节点”，用“查找”来确定插入位置

3、上升的关键字应该是原结点所属的父结点的指针的右边的位置，同时指针也对应挪动。

4、如果父结点的超出，那么重复分裂的操作，如果没有上一级结点，那么就创造一个新的结点。这种分裂操作如果一直到了根节点，那么可能会导致B树+1

# B树的删除

情况1：若被删除关键字在终端节点，则直接删除该关键字（要注意节点关键字个数是否低于下限 m/2 向下取整）【顺序存储的删除】

情况2:若【被删除关键字在非终端节点】，则用【直接前驱或直接后继来替代被删除的关键字】
直接前驱：当前关键字左侧指针所指子树中“最右下”的元素
直接后继：当前关键字右侧指针所指子树中“最左下”的元素
【tips：转变成直接删除对应的终端节点内的关键字】

情况3:兄弟够借。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法）

3-a：说白了，当【右兄弟很宽裕】时，用当前结点的后继（就是父节点指针右边的关键字拿来填补）、后继的后继（就是右兄弟的第一个节点填补父节点指针右边的关键字） 来填补空缺

3-b：说白了，当【左兄弟很宽裕】时，用当前结点的前驱（就是父节点指针左边的关键字拿来填补）、前驱的前驱（就是左兄弟的第一个节点填补父节点指针左边的关键字） 来填补空缺

情况4：兄弟不够借。若被删除关键字所在结点删除前的关鍵宇个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均=[m/2】—1，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。
在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键
字个数为7时，有2棵子树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到 m/2 —2，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B
树的要求为止。
如果根节点变成空节点，那么就删除根节点。