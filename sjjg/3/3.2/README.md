# 第三章、栈、队列和数组 
数据结构三要素——逻辑结构、数据的运算、存储结构（物理结构，存储结构不同，运算的实现方式不同）
## 3.2 队列
### 队列的定义
队列（Queue）是只允许在一端进行插入（入队），在另一端删除（出队）的有限制的线性表。
只能够在队头做删除操作，在队尾做添加操作。
#### 重要术语
- 队头：允许删除的一端，靠近队头的元素是队头元素；
- 队尾：允许进行插入的一端，靠近队尾的元素是队尾元素；
- 空队列：数据里没有任何数据；
队列的特点先进先出，First In First Out（FIFO）
### 队列的基本操作
- void InitQueue(&Q): 初始化队列，构造一个空队列Q
- void DestroyQueue(&Q): 销毁队列。销毁并释放队列Q所占用的内存空间
- _Bool EnQueue(&Q,x): 入队，若队列Q未满，将x加入，使之成为新的队尾
- _Bool DeQueue(&Q,&x): 出队，若队列Q非空，删除队头元素，并用x返回
- _Bool GetHead(Q,&x): 读队头元素，若队列Q非空，则将队头元素赋值给x
- _Bool QueueEmpty(Q): 判队列空，若队列Q为空返回true，否则返回false
### 队列的顺序存储实现 3.2.2.c
#### 注意点
- 循环队列: 用模运算将存储空间在逻辑上变成了“环装”
- 确定 front、rear指针的指向
- - ① rear 指向队尾元素最后一个位置
- - ② rear 指向队尾元素
- 确定判空判满的方法
- - a：牺牲一个存储单元；
- - b：增加size变量记录队列长度；
- - c：增加 tag = 0/1，用于标记最近的一次操作是 入队/出队
#### 考点
- 如何初始化、入队、出队
- 队尾指针指向的是A、队尾元素；B、队尾元素的下一元素
- 如何计算队列的长度（如何判空，判满，是否要牺牲存储单元）
思考，分别采用
1、①a①b①c 上面应该如何
2、②a②b②c 上面应该如何

### 队列的链式存储实现 3.2.3.c
#### 注意点
- 带头结点
- 不带头结点
#### 小点
- 求队列长度，要从队头节点开始遍历，需要时间复杂度为 O(n)，如果经常要访问的话，可以创建一个length变量，不用局限。

### 双端队列 3.2.4
- 受限制的线性表，只能够在两端进行插入和删除操作。
- 输入受限的双端队列：只允许从一端插入，两端删除的线性表；
- 输出受限的双端队列：只允许从两端插入，一端删除的线性表

## 考点
### 判断输出序列合法性
- 若数据元素输入序列为1,2,3,4，则哪些输出序列是合法的，哪些是非法的？
类型可有 $ A_{4}^{4}=24 $ 种
只要栈里面合法的，那么双端队列里也是合法的。
先排除是不是栈 > 是不是两端插入一端删除的操作
卡特兰数需要学会使用。
- 回忆：栈的变种--共享栈